{"version":3,"file":"static/chunks/4759.e8d0854ce8a49abe.js","mappings":"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","sources":["webpack://_N_E/../node_modules/invariant/browser.js","webpack://_N_E/../node_modules/lodash/_baseForOwn.js","webpack://_N_E/../node_modules/lodash/mapValues.js","webpack://_N_E/../packages/react-admin/node_modules/uniforms/esm/context.js","webpack://_N_E/../packages/react-admin/node_modules/uniforms/esm/joinName.js","webpack://_N_E/../packages/react-admin/node_modules/uniforms/esm/useForm.js","webpack://_N_E/../packages/react-admin/node_modules/uniforms/esm/useField.js","webpack://_N_E/../packages/react-admin/node_modules/uniforms/esm/connectField.js","webpack://_N_E/../packages/react-admin/lib-es/RaSelectReferenceInputField.js","webpack://_N_E/<anon>"],"sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n/**\n * Use invariant() to assert state which your program assumes to be true.\n *\n * Provide sprintf-style format (only %s is supported) and arguments\n * to provide information about what broke and what you were\n * expecting.\n *\n * The invariant message will be stripped in production, but the invariant\n * will remain to ensure logic does not differ in production.\n */\n\nvar invariant = function(condition, format, a, b, c, d, e, f) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (format === undefined) {\n      throw new Error('invariant requires an error message argument');\n    }\n  }\n\n  if (!condition) {\n    var error;\n    if (format === undefined) {\n      error = new Error(\n        'Minified exception occurred; use the non-minified dev environment ' +\n        'for the full error message and additional helpful warnings.'\n      );\n    } else {\n      var args = [a, b, c, d, e, f];\n      var argIndex = 0;\n      error = new Error(\n        format.replace(/%s/g, function() { return args[argIndex++]; })\n      );\n      error.name = 'Invariant Violation';\n    }\n\n    error.framesToPop = 1; // we don't care about invariant's own frame\n    throw error;\n  }\n};\n\nmodule.exports = invariant;\n","var baseFor = require('./_baseFor'),\n    keys = require('./keys');\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n","var baseAssignValue = require('./_baseAssignValue'),\n    baseForOwn = require('./_baseForOwn'),\n    baseIteratee = require('./_baseIteratee');\n\n/**\n * Creates an object with the same keys as `object` and values generated\n * by running each own enumerable string keyed property of `object` thru\n * `iteratee`. The iteratee is invoked with three arguments:\n * (value, key, object).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Object\n * @param {Object} object The object to iterate over.\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n * @returns {Object} Returns the new mapped object.\n * @see _.mapKeys\n * @example\n *\n * var users = {\n *   'fred':    { 'user': 'fred',    'age': 40 },\n *   'pebbles': { 'user': 'pebbles', 'age': 1 }\n * };\n *\n * _.mapValues(users, function(o) { return o.age; });\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n *\n * // The `_.property` iteratee shorthand.\n * _.mapValues(users, 'age');\n * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)\n */\nfunction mapValues(object, iteratee) {\n  var result = {};\n  iteratee = baseIteratee(iteratee, 3);\n\n  baseForOwn(object, function(value, key, object) {\n    baseAssignValue(result, key, iteratee(value, key, object));\n  });\n  return result;\n}\n\nmodule.exports = mapValues;\n","import { createContext } from 'react';\nexport const context = createContext(null);\n","const escapeMatch = /[.[\\]]/;\nconst escapeRegex = /\"/g;\n/** @internal */\nfunction escape(string) {\n    return string === '' || escapeMatch.test(string)\n        ? `[\"${string.replace(escapeRegex, '\\\\\"')}\"]`\n        : string;\n}\n/** @internal */\nfunction escapeToJoin(string, index) {\n    const escaped = escape(string);\n    return escaped === string ? (index ? `.${string}` : string) : escaped;\n}\nconst unescapeMatch = /^\\[\"(.*)\"]$/;\nconst unescapeRegex = /\\\\\"/g;\n/** @internal */\nfunction unescape(string) {\n    const match = unescapeMatch.exec(string);\n    return match ? match[1].replace(unescapeRegex, '\"') : string;\n}\n// This regular expression splits the string into three parts:\n//   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n//            front (hence prefix). It covers most standard usecases.\n//   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n//               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n//   `rest` is anything following the subscript. The leading dot (`.`)\n//          is stripped (`.a` -> `a`) if there is one. It is empty if\n//          `subscript` is empty.\n//\n// All three parts can be empty!\nconst nameRegex = /^([^.[\\]]*(?:\\.[^.[\\]]+)*)(?:\\.?(\\[\"(?:(?:[^\"]|\\\\\")*?[^\\\\])?\"])\\.?(.*))?$/;\n// eslint-disable-next-line complexity -- The complexity of it _is_ high.\nfunction joinNameImpl(...parts) {\n    // If the first argument is `null`, then we return an escaped array of parts.\n    // Otherwise, an escaped string is returned. As we may modify `parts` later,\n    // this has to be checked now.\n    const returnAsParts = parts[0] === null;\n    // Result parts (not escaped).\n    const name = [];\n    // This cannot be transformed into a `.forEach` loop and the length of it\n    // can not be memoized, as we modify `parts` as we go for performance reasons.\n    for (let index = 0; index !== parts.length; ++index) {\n        const part = parts[index];\n        // All falsy values except `0` are ignored.\n        if (part || part === 0) {\n            if (typeof part === 'string') {\n                // Strings are matched against the regular expression that split it into\n                // three parts (all can be empty):\n                //   `prefix` is a dotted name, e.g., `object.nested.2.field` at the\n                //            front (hence prefix). It covers most standard usecases.\n                //   `subscript` is a `[\"...\"]` subscript after the prefix. The content\n                //               within should be escaped by the user, e.g., `[\"\\\\\"\"]`.\n                //   `rest` is anything following the subscript. The leading dot (`.`)\n                //          is stripped (`.a` -> `a`) if there is one. It is empty if\n                //          `subscript` is empty.\n                const match = nameRegex.exec(part);\n                if (match) {\n                    const [, prefix, subscript, rest] = match;\n                    if (prefix) {\n                        // We could always `.split` the `prefix`, but it results in a severe\n                        // performance hit.\n                        if (prefix.includes('.')) {\n                            name.push(...prefix.split('.'));\n                        }\n                        else {\n                            name.push(prefix);\n                        }\n                    }\n                    if (subscript) {\n                        // We could adjust the `nameRegex` to skip brackets and `unescape`\n                        // to skip this check, but then every other call (e.g., a one in the\n                        // bridge) would have to know that. The performance is not affected\n                        // much by it anyway.\n                        name.push(unescape(subscript));\n                        // The `rest` is inlined in place as it is a single string.\n                        if (rest) {\n                            parts[index--] = rest;\n                        }\n                    }\n                }\n                else {\n                    // If a string is not matching the pattern, we leave it as it is. We\n                    // may want to raise a warning here as it should not happen. Most\n                    // likely it is something that should have been escaped (e.g., `[`).\n                    name.push(part);\n                }\n            }\n            else if (Array.isArray(part)) {\n                // Arrays are flattened in place but only if needed, i.e., they are not\n                // empty. We calculate the length of the overlapping parts to reuse the\n                // `parts` array as much as possible:\n                // [[], ...]              -> [[], ...]       // No change.\n                // [['a'], ...]           -> ['a', ...]      // Inline in place.\n                // [['a', 'b'], ...]      -> ['a', 'b', ...] // Inline with extension.\n                // ['a', ['b'], ...]      -> ['a', 'b', ...] // Inline in place.\n                // ['a', ['b', 'c'], ...] -> ['b', 'c', ...] // Inline with overlap.\n                if (part.length) {\n                    const length = Math.min(index + 1, part.length);\n                    index -= length;\n                    parts.splice(index + 1, length, ...part);\n                }\n            }\n            else {\n                // Other values -- most likely numbers and `true` -- are stringified.\n                name.push('' + part);\n            }\n        }\n    }\n    // We cannot escape the parts earlier as `escapeToJoin` depends on the index.\n    return returnAsParts ? name.map(escape) : name.map(escapeToJoin).join('');\n}\nexport const joinName = Object.assign(joinNameImpl, { escape, unescape });\n","import invariant from 'invariant';\nimport { useContext } from 'react';\nimport { context as contextReference } from './context';\nexport function useForm() {\n    const context = useContext(contextReference);\n    invariant(context !== null, 'useForm must be used within a form.');\n    return context;\n}\n","import get from 'lodash/get';\nimport mapValues from 'lodash/mapValues';\nimport { useCallback, useEffect, useMemo, useRef } from 'react';\nimport { joinName } from './joinName';\nimport { useForm } from './useForm';\nfunction propagate(prop, schema, state, fallback) {\n    const forcedFallbackInProp = prop === true || prop === undefined;\n    const forcedFallbackInSchema = schema === true || schema === undefined;\n    const schemaValue = forcedFallbackInSchema ? fallback : schema;\n    const value = prop === '' ||\n        prop === false ||\n        prop === null ||\n        (forcedFallbackInProp && (forcedFallbackInSchema || !state))\n        ? ''\n        : forcedFallbackInProp\n            ? schemaValue\n            : prop;\n    return [value, schemaValue];\n}\nexport function useField(fieldName, props, options) {\n    var _a;\n    const context = useForm();\n    const name = joinName((options === null || options === void 0 ? void 0 : options.absoluteName) ? '' : context.name, fieldName);\n    const field = context.schema.getField(name);\n    const usesInitialValue = (options === null || options === void 0 ? void 0 : options.initialValue) !== false;\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    const onChangeCalled = usesInitialValue ? useRef(false) : { current: false };\n    const state = mapValues(context.state, (prev, key) => {\n        const next = props[key];\n        return next !== null && next !== undefined ? !!next : prev;\n    });\n    const changed = !!get(context.changedMap, name);\n    const error = context.schema.getError(name, context.error);\n    const errorMessage = context.schema.getErrorMessage(name, context.error);\n    const fieldType = context.schema.getType(name);\n    const fields = context.schema.getSubfields(name);\n    const schemaProps = context.schema.getProps(name, Object.assign(Object.assign({}, state), props));\n    const [label, labelFallback] = propagate(props.label, schemaProps.label, state.label, '');\n    const [placeholder] = propagate(props.placeholder, schemaProps.placeholder, state.placeholder, label || labelFallback);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const id = useMemo(() => context.randomId(), []);\n    const onChange = useCallback((value, key = name) => {\n        onChangeCalled.current = true;\n        context.onChange(key, value);\n    }, \n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [context.onChange, name]);\n    const valueFromModel = get(context.model, name);\n    let initialValue;\n    let value = (_a = props.value) !== null && _a !== void 0 ? _a : valueFromModel;\n    if (usesInitialValue) {\n        if (!onChangeCalled.current) {\n            if (value === undefined) {\n                value = context.schema.getInitialValue(name, props);\n                initialValue = value;\n            }\n            else if (props.value !== undefined && props.value !== valueFromModel) {\n                initialValue = props.value;\n            }\n        }\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        useEffect(() => {\n            var _a;\n            const required = (_a = props.required) !== null && _a !== void 0 ? _a : schemaProps.required;\n            if (required && initialValue !== undefined) {\n                onChange(initialValue);\n            }\n            // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, []);\n    }\n    const fieldProps = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({ id }, state), { changed,\n        error,\n        errorMessage,\n        field,\n        fieldType,\n        fields,\n        onChange,\n        value }), schemaProps), props), { label,\n        name, \n        // TODO: Should we assert `typeof placeholder === 'string'`?\n        placeholder: placeholder });\n    return [fieldProps, context];\n}\n","import mapValues from 'lodash/mapValues';\nimport React from 'react';\nimport { context as contextReference } from './context';\nimport { useField } from './useField';\nfunction getNextContext(context, props, options) {\n    // Leaf components by definition do not affect the context. `AutoField` will\n    // skip most of them anyway, but if rendered directly we have to do it here.\n    // An example in the core theme are the `List*Field`s.\n    if ((options === null || options === void 0 ? void 0 : options.kind) === 'leaf') {\n        return context;\n    }\n    const changesName = props.name !== '';\n    const changesState = Object.keys(context.state).some(key => {\n        const next = props[key];\n        return next !== null && next !== undefined;\n    });\n    // There are no other ways of affecting the context.\n    if (!changesName && !changesState) {\n        return context;\n    }\n    const nextContext = Object.assign({}, context);\n    if (changesName) {\n        nextContext.name = nextContext.name.concat(props.name);\n    }\n    if (changesState) {\n        nextContext.state = mapValues(nextContext.state, (prev, key) => {\n            const next = props[key];\n            return next !== null && next !== undefined ? !!next : prev;\n        });\n    }\n    return nextContext;\n}\nexport function connectField(Component, options) {\n    function Field(props) {\n        const [fieldProps, context] = useField(props.name, props, options);\n        const nextContext = getNextContext(context, props, options);\n        const body = React.createElement(Component, Object.assign({}, props, fieldProps));\n        // If the context has not changed, then don't render the `Provider`. It's\n        // possible that it will change at some point, but it's extremely rare, as\n        // either `name` or one of the \"state props\" has to change.\n        if (context === nextContext) {\n            return body;\n        }\n        return React.createElement(contextReference.Provider, { children: body, value: nextContext });\n    }\n    Field.displayName = `${Component.displayName || Component.name}Field`;\n    return Object.assign(Field, { Component, options });\n}\n","var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ReferenceInput, SelectInput } from 'react-admin';\nimport { connectField } from 'uniforms';\nimport React from 'react';\n/**\n * RaSelectReferenceInputField can be used in an autoform to\n */\nvar RaSelectReferenceInputField = connectField(function (_a) {\n    var _b = _a.allowEmpty, allowEmpty = _b === void 0 ? true : _b, _c = _a.value, value = _c === void 0 ? null : _c, onChange = _a.onChange, optionText = _a.optionText, optionValue = _a.optionValue, label = _a.label, props = __rest(_a, [\"allowEmpty\", \"value\", \"onChange\", \"optionText\", \"optionValue\", \"label\"]);\n    return (React.createElement(ReferenceInput, { label: label, reference: props.reference, perPage: props.perPage, allowEmpty: allowEmpty, meta: {}, input: {\n            value: value,\n            onChange: function (e) {\n                onChange(e.target.value);\n            },\n        }, source: null },\n        React.createElement(SelectInput, { optionText: optionText || 'id', emptyValue: null, optionValue: optionValue || 'id', options: { value: value } })));\n});\nexport default RaSelectReferenceInputField;\n//# sourceMappingURL=RaSelectReferenceInputField.js.map"],"names":["module","exports","condition","format","a","b","c","d","e","f","error","undefined","args","argIndex","replace","name","framesToPop","baseFor","__webpack_require__","keys","object","iteratee","baseAssignValue","baseForOwn","baseIteratee","result","value","key","context_context","react","createContext","escapeMatch","escapeRegex","joinName_escape","string","test","escapeToJoin","index","escaped","unescapeMatch","unescapeRegex","joinName_unescape","match","exec","nameRegex","joinName","Object","assign","parts","returnAsParts","length","part","prefix","subscript","rest","includes","push","split","Array","isArray","Math","min","splice","map","join","escape","unescape","propagate","prop","schema","state","fallback","forcedFallbackInProp","forcedFallbackInSchema","schemaValue","__rest","s","t","p","prototype","hasOwnProperty","call","indexOf","getOwnPropertySymbols","i","propertyIsEnumerable","lib_es_RaSelectReferenceInputField","connectField","Component","options","Field","props","fieldProps","context","useField","fieldName","_a","initialValue","useForm","useContext","browser_default","absoluteName","field","getField","usesInitialValue","onChangeCalled","useRef","current","mapValues_default","prev","next","changed","get_default","changedMap","getError","errorMessage","getErrorMessage","fieldType","getType","fields","getSubfields","schemaProps","getProps","label","labelFallback","placeholder","id","useMemo","randomId","onChange","useCallback","valueFromModel","model","getInitialValue","useEffect","required","nextContext","getNextContext","kind","changesName","changesState","some","concat","body","createElement","Provider","children","displayName","_b","allowEmpty","_c","optionText","optionValue","ReferenceInput","Z","reference","perPage","meta","input","target","source","SelectInput","l","emptyValue"],"sourceRoot":""}